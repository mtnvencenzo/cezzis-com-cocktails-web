/* tslint:disable */
/* eslint-disable */
/**
 * Cezzi\'s Cocktails AI Search API
 * An AI-powered cocktail search API using semantic search and embeddings.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CocktailSearchDataIncludeModel,
  CocktailsSearchRs,
  ProblemDetails,
} from '../models/index';
import {
    CocktailSearchDataIncludeModelFromJSON,
    CocktailSearchDataIncludeModelToJSON,
    CocktailsSearchRsFromJSON,
    CocktailsSearchRsToJSON,
    ProblemDetailsFromJSON,
    ProblemDetailsToJSON,
} from '../models/index';

export interface GetV1CocktailsSearchRequest {
    X_Key: string;
    freetext?: string | null;
    skip?: number | null;
    take?: number | null;
    m?: Array<string> | null;
    m_ex?: boolean | null;
    inc?: Array<CocktailSearchDataIncludeModel> | null;
    fi?: Array<string> | null;
}

export interface GetV1CocktailsTypeaheadRequest {
    X_Key: string;
    freetext?: string | null;
    skip?: number | null;
    take?: number | null;
    fi?: Array<string> | null;
}

/**
 * SemanticSearchApi - interface
 * 
 * @export
 * @interface SemanticSearchApiInterface
 */
export interface SemanticSearchApiInterface {
    /**
     * Performs a semantic search for cocktails based on a free text query.
     * @summary Search
     * @param {string} X_Key The API gateway subscription key
     * @param {string} [freetext] The free text search term to match against
     * @param {number} [skip] The number of cocktail recipes to skip from the paged response
     * @param {number} [take] The number of cocktail recipes to take for pagination
     * @param {Array<string>} [m] A list of cocktails that can be included in the list
     * @param {boolean} [m_ex] Whether or not the supplied matches must be exclusively returned
     * @param {Array<CocktailSearchDataIncludeModel>} [inc] The list of extension objects to include for each cocktail recipe
     * @param {Array<string>} [fi] An optional list of filters to use when quering the cocktail recipes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApiInterface
     */
    getV1CocktailsSearchRaw(requestParameters: GetV1CocktailsSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CocktailsSearchRs>>;

    /**
     * Performs a semantic search for cocktails based on a free text query.
     * Search
     */
    getV1CocktailsSearch(requestParameters: GetV1CocktailsSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CocktailsSearchRs>;

    /**
     * Performs a typeahead search for cocktails based on a free text query.
     * @summary Typeahead
     * @param {string} X_Key The API gateway subscription key
     * @param {string} [freetext] The free text search term to match against
     * @param {number} [skip] The number of cocktail recipes to skip from the paged response
     * @param {number} [take] The number of cocktail recipes to take for pagination
     * @param {Array<string>} [fi] An optional list of filters to use when quering the cocktail recipes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApiInterface
     */
    getV1CocktailsTypeaheadRaw(requestParameters: GetV1CocktailsTypeaheadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CocktailsSearchRs>>;

    /**
     * Performs a typeahead search for cocktails based on a free text query.
     * Typeahead
     */
    getV1CocktailsTypeahead(requestParameters: GetV1CocktailsTypeaheadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CocktailsSearchRs>;

}

/**
 * 
 */
export class SemanticSearchApi extends runtime.BaseAPI implements SemanticSearchApiInterface {

    /**
     * Performs a semantic search for cocktails based on a free text query.
     * Search
     */
    async getV1CocktailsSearchRaw(requestParameters: GetV1CocktailsSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CocktailsSearchRs>> {
        if (requestParameters['X_Key'] == null) {
            throw new runtime.RequiredError(
                'X_Key',
                'Required parameter "X_Key" was null or undefined when calling getV1CocktailsSearch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['freetext'] != null) {
            queryParameters['freetext'] = requestParameters['freetext'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['take'] != null) {
            queryParameters['take'] = requestParameters['take'];
        }

        if (requestParameters['m'] != null) {
            queryParameters['m'] = requestParameters['m'];
        }

        if (requestParameters['m_ex'] != null) {
            queryParameters['m_ex'] = requestParameters['m_ex'];
        }

        if (requestParameters['inc'] != null) {
            queryParameters['inc'] = requestParameters['inc'];
        }

        if (requestParameters['fi'] != null) {
            queryParameters['fi'] = requestParameters['fi'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['X_Key'] != null) {
            headerParameters['X-Key'] = String(requestParameters['X_Key']);
        }


        let urlPath = `/v1/cocktails/search`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CocktailsSearchRsFromJSON(jsonValue));
    }

    /**
     * Performs a semantic search for cocktails based on a free text query.
     * Search
     */
    async getV1CocktailsSearch(requestParameters: GetV1CocktailsSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CocktailsSearchRs> {
        const response = await this.getV1CocktailsSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Performs a typeahead search for cocktails based on a free text query.
     * Typeahead
     */
    async getV1CocktailsTypeaheadRaw(requestParameters: GetV1CocktailsTypeaheadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CocktailsSearchRs>> {
        if (requestParameters['X_Key'] == null) {
            throw new runtime.RequiredError(
                'X_Key',
                'Required parameter "X_Key" was null or undefined when calling getV1CocktailsTypeahead().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['freetext'] != null) {
            queryParameters['freetext'] = requestParameters['freetext'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['take'] != null) {
            queryParameters['take'] = requestParameters['take'];
        }

        if (requestParameters['fi'] != null) {
            queryParameters['fi'] = requestParameters['fi'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['X_Key'] != null) {
            headerParameters['X-Key'] = String(requestParameters['X_Key']);
        }


        let urlPath = `/v1/cocktails/typeahead`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CocktailsSearchRsFromJSON(jsonValue));
    }

    /**
     * Performs a typeahead search for cocktails based on a free text query.
     * Typeahead
     */
    async getV1CocktailsTypeahead(requestParameters: GetV1CocktailsTypeaheadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CocktailsSearchRs> {
        const response = await this.getV1CocktailsTypeaheadRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
