//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { CocktailsApiClientBase } from './cocktailsApiClientBase';

export class CocktailsApiClient extends CocktailsApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("http://localhost:7177/", baseUrl);
    }

    /**
     * @param freeText (optional) The free text search term to match against
     * @param skip (optional) The number of cocktail recipes to skip from the paged response
     * @param take (optional) The number of cocktail recipes to return
     * @param m (optional) A list of cocktails that can be included in the list
     * @param match_exclusive (optional) Whether or not the supplied matches must be exclusively returned
     * @param inc (optional) The list of extension objects to include for each cocktail recipe
     * @param sf (optional) An optional list of filters to use when quering the cocktail recipes
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getCocktailsList(freeText?: string | undefined, skip?: number | undefined, take?: number | undefined, m?: string[] | undefined, match_exclusive?: boolean | undefined, inc?: CocktailDataIncludeModel[] | undefined, sf?: string[] | undefined, x_Key?: string | undefined): Promise<CocktailsListRs> {
        let url_ = this.baseUrl + "/api/v1/cocktails?";
        if (freeText === null)
            throw new Error("The parameter 'freeText' cannot be null.");
        else if (freeText !== undefined)
            url_ += "freeText=" + encodeURIComponent("" + freeText) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (m === null)
            throw new Error("The parameter 'm' cannot be null.");
        else if (m !== undefined)
            m && m.forEach(item => { url_ += "m=" + encodeURIComponent("" + item) + "&"; });
        if (match_exclusive === null)
            throw new Error("The parameter 'match_exclusive' cannot be null.");
        else if (match_exclusive !== undefined)
            url_ += "match-exclusive=" + encodeURIComponent("" + match_exclusive) + "&";
        if (inc === null)
            throw new Error("The parameter 'inc' cannot be null.");
        else if (inc !== undefined)
            inc && inc.forEach(item => { url_ += "inc=" + encodeURIComponent("" + item) + "&"; });
        if (sf === null)
            throw new Error("The parameter 'sf' cannot be null.");
        else if (sf !== undefined)
            sf && sf.forEach(item => { url_ += "sf=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCocktailsList(_response));
        });
    }

    protected processGetCocktailsList(response: Response): Promise<CocktailsListRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CocktailsListRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return No Content
     */
    seedCocktails(x_Key?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/cocktails";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSeedCocktails(_response));
        });
    }

    protected processSeedCocktails(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param id The cocktail recipe unique identifier
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getCocktail(id: string, x_Key?: string | undefined): Promise<CocktailRs> {
        let url_ = this.baseUrl + "/api/v1/cocktails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCocktail(_response));
        });
    }

    protected processGetCocktail(response: Response): Promise<CocktailRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CocktailRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getCocktailIngredientFilters(x_Key?: string | undefined): Promise<CocktailIngredientFiltersRs> {
        let url_ = this.baseUrl + "/api/v1/cocktails/ingredients/filters";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCocktailIngredientFilters(_response));
        });
    }

    protected processGetCocktailIngredientFilters(response: Response): Promise<CocktailIngredientFiltersRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CocktailIngredientFiltersRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return No Content
     */
    seedIngredients(x_Key?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/cocktails/ingredients";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSeedIngredients(_response));
        });
    }

    protected processSeedIngredients(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getPrivacyPolicy(x_Key?: string | undefined): Promise<LegalDocumentRs> {
        let url_ = this.baseUrl + "/api/v1/legal/documents/privacy-policy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPrivacyPolicy(_response));
        });
    }

    protected processGetPrivacyPolicy(response: Response): Promise<LegalDocumentRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LegalDocumentRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getTermsOfService(x_Key?: string | undefined): Promise<LegalDocumentRs> {
        let url_ = this.baseUrl + "/api/v1/legal/documents/terms-of-service";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetTermsOfService(_response));
        });
    }

    protected processGetTermsOfService(response: Response): Promise<LegalDocumentRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LegalDocumentRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getAccountOwnedProfile(x_Key?: string | undefined): Promise<AccountOwnedProfileRs> {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAccountOwnedProfile(_response));
        });
    }

    protected processGetAccountOwnedProfile(response: Response): Promise<AccountOwnedProfileRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountOwnedProfileRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @param body (optional) 
     * @return OK
     */
    updateAccountOwnedProfile(x_Key?: string | undefined, body?: UpdateAccountOwnedProfileRq | undefined): Promise<AccountOwnedProfileRs> {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateAccountOwnedProfile(_response));
        });
    }

    protected processUpdateAccountOwnedProfile(response: Response): Promise<AccountOwnedProfileRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountOwnedProfileRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @param body (optional) 
     * @return OK
     */
    updateAccountOwnedProfileEmail(x_Key?: string | undefined, body?: UpdateAccountOwnedProfileEmailRq | undefined): Promise<AccountOwnedProfileRs> {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateAccountOwnedProfileEmail(_response));
        });
    }

    protected processUpdateAccountOwnedProfileEmail(response: Response): Promise<AccountOwnedProfileRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountOwnedProfileRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @param body (optional) 
     * @return OK
     */
    updateAccountOwnedAccessibilitySettings(x_Key?: string | undefined, body?: UpdateAccountOwnedAccessibilitySettingsRq | undefined): Promise<AccountOwnedProfileRs> {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/accessibility";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateAccountOwnedAccessibilitySettings(_response));
        });
    }

    protected processUpdateAccountOwnedAccessibilitySettings(response: Response): Promise<AccountOwnedProfileRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountOwnedProfileRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return Created
     */
    uploadProfileImage(body: Body, x_Key?: string | undefined): Promise<UploadProfileImageRs> {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/image";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "multipart/form-data; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUploadProfileImage(_response));
        });
    }

    protected processUploadProfileImage(response: Response): Promise<UploadProfileImageRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UploadProfileImageRs;
            return result201;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @param body (optional) 
     * @return OK
     */
    manageFavoriteCocktails(x_Key?: string | undefined, body?: ManageFavoriteCocktailsRq | undefined): Promise<AccountOwnedProfileRs> {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/cocktails/favorites";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processManageFavoriteCocktails(_response));
        });
    }

    protected processManageFavoriteCocktails(response: Response): Promise<AccountOwnedProfileRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountOwnedProfileRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @param body (optional) 
     * @return Created
     */
    rateCocktail(x_Key?: string | undefined, body?: RateCocktailRq | undefined): Promise<RateCocktailRs> {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/cocktails/ratings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRateCocktail(_response));
        });
    }

    protected processRateCocktail(response: Response): Promise<RateCocktailRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateCocktailRs;
            return result201;
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getCocktailRatings(x_Key?: string | undefined): Promise<AccountCocktailRatingsRs> {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/cocktails/ratings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCocktailRatings(_response));
        });
    }

    protected processGetCocktailRatings(response: Response): Promise<AccountCocktailRatingsRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountCocktailRatingsRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param body The cocktail recommendation request body
     * @param x_Key (optional) Subscription key
     * @return Accepted
     */
    sendCocktailRecommendation(body: CocktailRecommendationRq, x_Key?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/cocktails/recommendations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSendCocktailRecommendation(_response));
        });
    }

    protected processSendCocktailRecommendation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

/** The accessibility settings for the account visible to other users */
export interface AccountAccessibilitySettingsModel {
    theme: DisplayThemeModel;

    [key: string]: any;
}

/** The optional primary address listed with the account */
export interface AccountAddressModel {
    /** The primary street address. */
    addressLine1: string;
    /** The secondary street address building sub divider */
    addressLine2: string;
    /** The city the address is within */
    city: string;
    /** The state or province */
    region: string;
    /** The state or province divered such as county */
    subRegion: string;
    /** The postal or zip code */
    postalCode: string;
    /** The country */
    country: string;

    [key: string]: any;
}

/** The cocktail rating values */
export interface AccountCocktailRatingModel {
    /** The number of one star ratings */
    oneStars: number;
    /** The number of two star ratings */
    twoStars: number;
    /** The number of three star ratings */
    threeStars: number;
    /** The number of four star ratings */
    fourStars: number;
    /** The number of five star ratings */
    fiveStars: number;
    /** The total number of stars given */
    totalStars: number;
    /** The actual overal rating */
    rating: number;
    /** The total number of ratings given */
    ratingCount: number;

    [key: string]: any;
}

export interface AccountCocktailRatingsModel {
    /** The cocktail identifier */
    cocktailId: string;
    /** The rating for the cocktail (1-5) */
    stars: number;

    [key: string]: any;
}

export interface AccountCocktailRatingsRs {
    /** The cocktail ratings */
    ratings: AccountCocktailRatingsModel[];

    [key: string]: any;
}

export interface AccountOwnedProfileRs {
    /** The federated subject identifier for the account */
    subjectId: string;
    /** The login email address for the account */
    loginEmail: string;
    /** The email address for the account */
    email: string;
    /** The given name on the account */
    givenName: string;
    /** The family name on the account */
    familyName: string;
    /** The avatar image uri for the account */
    avatarUri: string;
    primaryAddress: AccountAddressModel;
    /** The display name for the account visible to other users */
    displayName: string;
    accessibility: AccountAccessibilitySettingsModel;
    /** The list of favorite cocktails */
    favoriteCocktails: string[];

    [key: string]: any;
}

export enum CocktailDataIncludeModel {
    MainImages = "mainImages",
    SearchTiles = "searchTiles",
    DescriptiveTitle = "descriptiveTitle",
}

export interface CocktailFavoriteActionModel {
    /** The cocktail identifier */
    cocktailId: string;
    action: CocktailFavoritingActionModel;

    [key: string]: any;
}

/** The action to take on the cocktail within the favorites list */
export enum CocktailFavoritingActionModel {
    Add = "add",
    Remove = "remove",
}

export interface CocktailImageModel {
    /** The uri of the image */
    uri: string;
    /** The width of the image */
    width: number;
    /** The height of the image */
    height: number;

    [key: string]: any;
}

export interface CocktailImageModel2 {
    /** The uri of the image */
    uri: string;
    /** The width of the image */
    width: number;
    /** The height of the image */
    height: number;

    [key: string]: any;
}

export interface CocktailIngredientFiltersRs {
    /** The cocktail ingredient filters for searching against recommended glassware */
    glassware: IngredientFilterModel[];
    /** The cocktail ingredient filters for searching against spirits */
    spirits: IngredientFilterModel2[];
    /** The cocktail ingredient filters for searching against liqueurs */
    liqueurs: IngredientFilterModel3[];
    /** The cocktail ingredient filters for searching against friuts */
    fruits: IngredientFilterModel4[];
    /** The cocktail ingredient filters for searching against vegetables */
    vegetables: IngredientFilterModel5[];
    /** The cocktail ingredient filters for searching against herbs and flowers */
    herbsAndFlowers: IngredientFilterModel6[];
    /** The cocktail ingredient filters for searching against syrups and sauces */
    syrupsAndSauces: IngredientFilterModel7[];
    /** The cocktail ingredient filters for searching against bitters */
    bitters: IngredientFilterModel8[];
    /** The cocktail ingredient filters for searching against proteins */
    proteins: IngredientFilterModel9[];
    /** The cocktail ingredient filters for searching against juices */
    juices: IngredientFilterModel10[];
    /** The cocktail ingredient filters for searching against dilutions */
    dilutions: IngredientFilterModel11[];
    /** The cocktail ingredient filters for searching against beers, wines and champagnes */
    beerWineChampagne: IngredientFilterModel12[];
    /** The cocktail ingredient filters for searching against eras when cocktails were established */
    eras: IngredientFilterModel13[];

    [key: string]: any;
}

/** The cocktail recipe model */
export interface CocktailModel {
    /** The cocktail recipe unique identifier */
    id: string;
    /** The name of the cocktail recipe */
    title: string;
    /** A more descriptive title for the cocktail recipe, generally used as an editorial title */
    descriptiveTitle: string;
    /** A brief editorial description for the cocktail recipe */
    description: string;
    /** The complete descriptive cocktail recipe including ingredients, directions and historical information in markdown format */
    content: string;
    /** The date this cocktail recipe was published on Cezzis.Com */
    publishedOn: Date;
    /** The date this cocktail recipe was last modified on Cezzis.Com */
    modifiedOn: Date;
    /** The number of people the cocktail recipe serves */
    serves: number;
    /** The average number of minutes to build the cocktail using this recipe */
    prepTimeMinutes: number;
    /** Whether or not the cocktail represented by this recipe is recognized by the International Bartenders Association */
    isIba: boolean;
    /** A list of primary images for the cocktail recipe */
    mainImages: CocktailImageModel[];
    /** A list of secondary, smaller sized images for the cocktail recipe */
    searchTiles: CocktailImageModel2[];
    /** The recommended glassware to use when serving the cocktail */
    glassware: GlasswareTypeModel[];
    rating: CocktailRatingModel;
    /** A list of titles that are queried against when issuing cocktail recipe search queries */
    searchableTitles: string[];
    /** A list of taxonomy tags defining the cocktail recipe */
    tags: string[];
    /** The list of ingredients that make up the cocktail recipe */
    ingredients: IngredientModel[];
    /** The list of instructions to make the cocktail recipe */
    instructions: InstructionStepModel[];

    [key: string]: any;
}

/** A ratings for this cocktail */
export interface CocktailRatingModel {
    /** The number of one star ratings */
    oneStars: number;
    /** The number of two star ratings */
    twoStars: number;
    /** The number of three star ratings */
    threeStars: number;
    /** The number of four star ratings */
    fourStars: number;
    /** The number of five star ratings */
    fiveStars: number;
    /** The total number of stars given */
    totalStars: number;
    /** The actual overal rating */
    rating: number;
    /** The total number of ratings given */
    ratingCount: number;

    [key: string]: any;
}

/** The cocktail recommendation model */
export interface CocktailRecommendationModel {
    /** The name of the cocktail or variation */
    name: string;
    /** The ingredients description of the cocktail or variation */
    ingredients: string;
    /** The directions description of the cocktail or variation */
    directions: string;

    [key: string]: any;
}

export interface CocktailRecommendationRq {
    recommendation: CocktailRecommendationModel;
    /** The google recaptcha verification code returned after being valid */
    verificationCode: string;

    [key: string]: any;
}

export interface CocktailRs {
    item: CocktailModel;

    [key: string]: any;
}

export interface CocktailsListModel {
    /** The cocktail recipe unique identifier */
    id: string;
    /** The name of the cocktail recipe */
    title: string;
    /** A more descriptive title for the cocktail recipe, generally used as an editorial title */
    descriptiveTitle: string;
    /** The overral rating for the recipe */
    rating: number;
    /** The list of ingredients that make up the cocktail recipe */
    ingredients: IngredientModel[];
    /** Whether or not the cocktail represented by this recipe is recognized by the International Bartenders Association */
    isIba: boolean;
    /** The number of people the cocktail recipe serves */
    serves: number;
    /** The average number of minutes to build the cocktail using this recipe */
    prepTimeMinutes: number;
    /** A list of primary image uris for the cocktail recipe */
    mainImages: string[];
    /** A list of secondary, smaller sized image uris for the cocktail recipe */
    searchTiles: string[];
    /** The recommended glassware to use when serving the cocktail */
    glassware: GlasswareTypeModel[];

    [key: string]: any;
}

export interface CocktailsListRs {
    /** A list of cocktail recipe list models */
    items: CocktailsListModel[];

    [key: string]: any;
}

/** The accessibility theme */
export enum DisplayThemeModel {
    Light = "light",
    Dark = "dark",
}

/** The display theme (light, dark) */
export enum DisplayThemeModel2 {
    Light = "light",
    Dark = "dark",
}

/** The format that the document content is in */
export enum DocumentFormat {
    Markdown = "markdown",
}

export enum GlasswareTypeModel {
    None = "none",
    Rocks = "rocks",
    Highball = "highball",
    ShotGlass = "shotGlass",
    Coupe = "coupe",
    CopperMug = "copperMug",
    Collins = "collins",
    CocktailGlass = "cocktailGlass",
    WineGlass = "wineGlass",
    Flute = "flute",
    Lowball = "lowball",
    Fizz = "fizz",
    TikiMug = "tikiMug",
    PintGlass = "pintGlass",
    JulepTin = "julepTin",
    DoubleRocks = "doubleRocks",
    Hurricane = "hurricane",
    HollowedPineapple = "hollowedPineapple",
    Snifter = "snifter",
    ScorpionBowl = "scorpionBowl",
}

export enum IngredientApplicationModel {
    Base = "base",
    Additional = "additional",
    Garnishment = "garnishment",
    Muddle = "muddle",
}

export interface IngredientFilterModel {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel10 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel11 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel12 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel13 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel2 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel3 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel4 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel5 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel6 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel7 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel8 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientFilterModel9 {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientModel {
    /** The name of the ingredient */
    name: string;
    uoM: UofMTypeModel;
    requirement: IngredientRequirementTypeModel;
    /** Gets the complete display value for the ingredient including units and measurments */
    display: string;
    /** The number of units to use in relation to the UoM (unit of measure) in the cocktail recipe */
    units: number;
    preparation: PreparationTypeModel;
    /** Suggestion when using this ingredient */
    suggestions: string;
    /** The ingredient types that this ingredient is in relation to the cocktail recipe */
    types: IngredientTypeModel[];
    /** The ingredient applications that this ingredient is in relation to the cocktail recipe */
    applications: IngredientApplicationModel[];

    [key: string]: any;
}

/** Whether or not this ingredient is required ('Required' or 'Optional') */
export enum IngredientRequirementTypeModel {
    None = "none",
    Optional = "optional",
    Required = "required",
}

export enum IngredientTypeModel {
    Herb = "herb",
    Fruit = "fruit",
    Juice = "juice",
    Bitters = "bitters",
    Syrup = "syrup",
    Protein = "protein",
    Flowers = "flowers",
    Sauce = "sauce",
    Vegetable = "vegetable",
    Dilution = "dilution",
    Beer = "beer",
    Spirit = "spirit",
    Liqueur = "liqueur",
    Wine = "wine",
    Champagne = "champagne",
}

export interface InstructionStepModel {
    /** The displayable value for the instruction step */
    display: string;
    /** The order of the instruction step in which it should be performed */
    order: number;

    [key: string]: any;
}

export interface LegalDocumentRs {
    /** The document content */
    document: string;
    format: DocumentFormat;

    [key: string]: any;
}

export interface ManageFavoriteCocktailsRq {
    cocktailActions: CocktailFavoriteActionModel[];

    [key: string]: any;
}

/** Any preparation that should be made with this ingredient */
export enum PreparationTypeModel {
    None = "none",
    Chilled = "chilled",
    FreshlySqueezed = "freshlySqueezed",
    PeeledAndJuiced = "peeledAndJuiced",
    FreshlyGrated = "freshlyGrated",
    Quartered = "quartered",
    FreshPressed = "freshPressed",
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export interface RateCocktailRq {
    /** The cocktail identifier */
    cocktailId: string;
    /** The rating for the cocktail (1-5) */
    stars: number;

    [key: string]: any;
}

export interface RateCocktailRs {
    /** The cocktail ratings */
    ratings: AccountCocktailRatingsModel[];
    /** The cocktail identifier */
    cocktailId: string;
    cocktailRating: AccountCocktailRatingModel;

    [key: string]: any;
}

/** The unit of measure when using this ingredient in a cocktail recipe */
export enum UofMTypeModel {
    None = "none",
    Ounces = "ounces",
    Dashes = "dashes",
    Tablespoon = "tablespoon",
    Topoff = "topoff",
    Item = "item",
    Teaspoon = "teaspoon",
    ToTaste = "toTaste",
    Barspoon = "barspoon",
    Cups = "cups",
    Splash = "splash",
    Discretion = "discretion",
}

export interface UpdateAccountOwnedAccessibilitySettingsRq {
    theme: DisplayThemeModel2;

    [key: string]: any;
}

export interface UpdateAccountOwnedProfileEmailRq {
    /** The email address for the account */
    email: string;

    [key: string]: any;
}

export interface UpdateAccountOwnedProfileRq {
    /** The given name on the account */
    givenName: string;
    /** The family name on the account */
    familyName: string;
    /** The display for the account visible to other users */
    displayName: string;
    primaryAddress: AccountAddressModel;

    [key: string]: any;
}

export interface UploadProfileImageRs {
    /** The uri for the image that was uploaded */
    imageUri: string;

    [key: string]: any;
}

export interface Body {
    file?: string;

    [key: string]: any;
}

export class CocktailsApiClientException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isCocktailsApiClientException = true;

    static isCocktailsApiClientException(obj: any): obj is CocktailsApiClientException {
        return obj.isCocktailsApiClientException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new CocktailsApiClientException(message, status, response, headers, null);
}

/* tslint:disable */
/* eslint-disable */

if (CocktailsApiClientBase) {}