//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { CocktailsApiClientBase } from './cocktailsApiClientBase';

export class CocktailsApiClient extends CocktailsApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("http://localhost:7179/", baseUrl);
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return No Content
     */
    seedCocktails(x_Key?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/cocktails";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSeedCocktails(_response));
        });
    }

    protected processSeedCocktails(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param id The cocktail recipe unique identifier
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getCocktail(id: string, x_Key?: string | undefined): Promise<CocktailRs> {
        let url_ = this.baseUrl + "/api/v1/cocktails/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCocktail(_response));
        });
    }

    protected processGetCocktail(response: Response): Promise<CocktailRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CocktailRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getCocktailIngredientFilters(x_Key?: string | undefined): Promise<CocktailIngredientFiltersRs> {
        let url_ = this.baseUrl + "/api/v1/cocktails/ingredients/filters";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCocktailIngredientFilters(_response));
        });
    }

    protected processGetCocktailIngredientFilters(response: Response): Promise<CocktailIngredientFiltersRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CocktailIngredientFiltersRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return No Content
     */
    seedIngredients(x_Key?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/cocktails/ingredients";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSeedIngredients(_response));
        });
    }

    protected processSeedIngredients(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param body The request to publish cocktails to external systems
     * @param x_Key (optional) Subscription key
     * @return No Content
     */
    publishCocktails(body: PublishCocktailsRq, x_Key?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/cocktails/admin/pub";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPublishCocktails(_response));
        });
    }

    protected processPublishCocktails(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getPrivacyPolicy(x_Key?: string | undefined): Promise<LegalDocumentRs> {
        let url_ = this.baseUrl + "/api/v1/legal/documents/privacy-policy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPrivacyPolicy(_response));
        });
    }

    protected processGetPrivacyPolicy(response: Response): Promise<LegalDocumentRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LegalDocumentRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getTermsOfService(x_Key?: string | undefined): Promise<LegalDocumentRs> {
        let url_ = this.baseUrl + "/api/v1/legal/documents/terms-of-service";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetTermsOfService(_response));
        });
    }

    protected processGetTermsOfService(response: Response): Promise<LegalDocumentRs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LegalDocumentRs;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    init(x_Key?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/job/initialize-app";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processInit(_response));
        });
    }

    protected processInit(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface CocktailImageModel {
    /** The uri of the image */
    uri: string;
    /** The width of the image */
    width: number;
    /** The height of the image */
    height: number;

    [key: string]: any;
}

export interface CocktailImageModel2 {
    /** The uri of the image */
    uri: string;
    /** The width of the image */
    width: number;
    /** The height of the image */
    height: number;

    [key: string]: any;
}

export interface CocktailIngredientFiltersRs {
    /** The cocktail ingredient filters for searching against recommended glassware */
    glassware: IngredientFilterModel[];
    /** The cocktail ingredient filters for searching against spirits */
    spirits: any[];
    /** The cocktail ingredient filters for searching against liqueurs */
    liqueurs: any[];
    /** The cocktail ingredient filters for searching against friuts */
    fruits: any[];
    /** The cocktail ingredient filters for searching against vegetables */
    vegetables: any[];
    /** The cocktail ingredient filters for searching against herbs and flowers */
    herbsAndFlowers: any[];
    /** The cocktail ingredient filters for searching against syrups and sauces */
    syrupsAndSauces: any[];
    /** The cocktail ingredient filters for searching against bitters */
    bitters: any[];
    /** The cocktail ingredient filters for searching against proteins */
    proteins: any[];
    /** The cocktail ingredient filters for searching against juices */
    juices: any[];
    /** The cocktail ingredient filters for searching against dilutions */
    dilutions: any[];
    /** The cocktail ingredient filters for searching against beers, wines and champagnes */
    beerWineChampagne: any[];
    /** The cocktail ingredient filters for searching against eras when cocktails were established */
    eras: any[];

    [key: string]: any;
}

/** The cocktail recipe model */
export interface CocktailModel {
    /** The cocktail recipe unique identifier */
    id: string;
    /** The name of the cocktail recipe */
    title: string;
    /** A more descriptive title for the cocktail recipe, generally used as an editorial title */
    descriptiveTitle: string;
    /** A brief editorial description for the cocktail recipe */
    description: string;
    /** The complete descriptive cocktail recipe including ingredients, directions and historical information in markdown format */
    content: string;
    /** The date this cocktail recipe was published on Cezzis.Com */
    publishedOn: Date;
    /** The date this cocktail recipe was last modified on Cezzis.Com */
    modifiedOn: Date;
    /** The number of people the cocktail recipe serves */
    serves: number;
    /** The average number of minutes to build the cocktail using this recipe */
    prepTimeMinutes: number;
    /** Whether or not the cocktail represented by this recipe is recognized by the International Bartenders Association */
    isIba: boolean;
    /** A list of primary images for the cocktail recipe */
    mainImages: CocktailImageModel[];
    /** A list of secondary, smaller sized images for the cocktail recipe */
    searchTiles: CocktailImageModel2[];
    /** The recommended glassware to use when serving the cocktail */
    glassware: GlasswareTypeModel[];
    rating: CocktailRatingModel;
    /** A list of titles that are queried against when issuing cocktail recipe search queries */
    searchableTitles: string[];
    /** A list of taxonomy tags defining the cocktail recipe */
    tags: string[];
    /** The list of ingredients that make up the cocktail recipe */
    ingredients: IngredientModel[];
    /** The list of instructions to make the cocktail recipe */
    instructions: InstructionStepModel[];

    [key: string]: any;
}

/** A ratings for this cocktail */
export interface CocktailRatingModel {
    /** The number of one star ratings */
    oneStars: number;
    /** The number of two star ratings */
    twoStars: number;
    /** The number of three star ratings */
    threeStars: number;
    /** The number of four star ratings */
    fourStars: number;
    /** The number of five star ratings */
    fiveStars: number;
    /** The total number of stars given */
    totalStars: number;
    /** The actual overal rating */
    rating: number;
    /** The total number of ratings given */
    ratingCount: number;

    [key: string]: any;
}

export interface CocktailRs {
    item: CocktailModel;

    [key: string]: any;
}

/** The format that the document content is in */
export enum DocumentFormat {
    Markdown = "markdown",
}

export enum GlasswareTypeModel {
    None = "none",
    Rocks = "rocks",
    Highball = "highball",
    ShotGlass = "shotGlass",
    Coupe = "coupe",
    CopperMug = "copperMug",
    Collins = "collins",
    CocktailGlass = "cocktailGlass",
    WineGlass = "wineGlass",
    Flute = "flute",
    Lowball = "lowball",
    Fizz = "fizz",
    TikiMug = "tikiMug",
    PintGlass = "pintGlass",
    JulepTin = "julepTin",
    DoubleRocks = "doubleRocks",
    Hurricane = "hurricane",
    HollowedPineapple = "hollowedPineapple",
    Snifter = "snifter",
    ScorpionBowl = "scorpionBowl",
}

export enum IngredientApplicationModel {
    Base = "base",
    Additional = "additional",
    Garnishment = "garnishment",
    Muddle = "muddle",
}

export interface IngredientFilterModel {
    /** The filter identifier */
    id: string;
    /** The display name of the filter */
    name: string;

    [key: string]: any;
}

export interface IngredientModel {
    /** The name of the ingredient */
    name: string;
    uoM: UofMTypeModel;
    requirement: IngredientRequirementTypeModel;
    /** Gets the complete display value for the ingredient including units and measurments */
    display: string;
    /** The number of units to use in relation to the UoM (unit of measure) in the cocktail recipe */
    units: number;
    preparation: PreparationTypeModel;
    /** Suggestion when using this ingredient */
    suggestions: string;
    /** The ingredient types that this ingredient is in relation to the cocktail recipe */
    types: IngredientTypeModel[];
    /** The ingredient applications that this ingredient is in relation to the cocktail recipe */
    applications: IngredientApplicationModel[];

    [key: string]: any;
}

/** Whether or not this ingredient is required ('Required' or 'Optional') */
export enum IngredientRequirementTypeModel {
    None = "none",
    Optional = "optional",
    Required = "required",
}

export enum IngredientTypeModel {
    Herb = "herb",
    Fruit = "fruit",
    Juice = "juice",
    Bitters = "bitters",
    Syrup = "syrup",
    Protein = "protein",
    Flowers = "flowers",
    Sauce = "sauce",
    Vegetable = "vegetable",
    Dilution = "dilution",
    Beer = "beer",
    Spirit = "spirit",
    Liqueur = "liqueur",
    Wine = "wine",
    Champagne = "champagne",
}

export interface InstructionStepModel {
    /** The displayable value for the instruction step */
    display: string;
    /** The order of the instruction step in which it should be performed */
    order: number;

    [key: string]: any;
}

export interface LegalDocumentRs {
    /** The document content */
    document: string;
    format: DocumentFormat;

    [key: string]: any;
}

/** Any preparation that should be made with this ingredient */
export enum PreparationTypeModel {
    None = "none",
    Chilled = "chilled",
    FreshlySqueezed = "freshlySqueezed",
    PeeledAndJuiced = "peeledAndJuiced",
    FreshlyGrated = "freshlyGrated",
    Quartered = "quartered",
    FreshPressed = "freshPressed",
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export interface PublishCocktailsRq {
    /** A list of cocktail IDs to publish */
    cocktailIds: string[];

    [key: string]: any;
}

/** The unit of measure when using this ingredient in a cocktail recipe */
export enum UofMTypeModel {
    None = "none",
    Ounces = "ounces",
    Dashes = "dashes",
    Tablespoon = "tablespoon",
    Topoff = "topoff",
    Item = "item",
    Teaspoon = "teaspoon",
    ToTaste = "toTaste",
    Barspoon = "barspoon",
    Cups = "cups",
    Splash = "splash",
    Discretion = "discretion",
}

export class CocktailsApiClientException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isCocktailsApiClientException = true;

    static isCocktailsApiClientException(obj: any): obj is CocktailsApiClientException {
        return obj.isCocktailsApiClientException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new CocktailsApiClientException(message, status, response, headers, null);
}

/* tslint:disable */
/* eslint-disable */

if (CocktailsApiClientBase) {}